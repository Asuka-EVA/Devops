# 随堂文档

前置内容

```
前提：
	今天的环境 ubuntu 或者 centos 都可以
	
目标：
	了解 bash是干什么的，工作定位什么
	基本的语法 - 变量、表达式、逻辑控制
	
环境：
	1台 ubuntu 或者 centos 主机
```

## 基础知识

### 语言简介

小结

```
shell 命令解释器

分类：
	图形
	命令行 - bash
	
信息：
	$SHELL
	/etc/shells
	
方式：
	手工 - 逐行输入、逐行确认、逐行执行
	脚本 - 可执行命令的 组合
	
示例
#!/bin/bash
# 这是我第一个脚本，请多关照

echo $SHELL
cat /etc/shells
```

### 简单实践

小结

```
文件
	工具 vim等
	名称 有意义，后缀.sh
	内容 可执行命令
	注释 单行注释(#)、多行注释(:<<字符。。。字符)
	
执行
	/bin/bash /path/to/script-name
		优先推荐
	/path/to/script-name
		文件权限
	source /path/to/script-name
		环境加载场景
		
技巧
	shell脚本开发规范重点：
        首行		 解释器
        文件执行 	bash 文件名
        内容执行 	从上到下，依次执行
	shell脚本开发小技巧：
		注释(方便理解)、成对写(避免犯错)、缩进(好看)
```

### 变量基础

小结

```
分类
	本地 - 在当前环境下有效
		普通的
			变量名=变量值		变量值范围中不允许有特殊符号
			变量名='变量值'	原字符输出
			变量名="变量值"	先看范围有无可解析的内容，如果有的话，先解析后赋值
		命令的
			变量名=`变量值`	反引号
			变量名=$(变量值)
			流程：
				先执行命令然后将命令的结果交给变量名
	全局 - 当前系统下有效
		查看  env
		定制  export 变量名=变量值
	内置 - 直接使用bash定制的
	

```

### 变量实践

小结

```
常见内置变量
	最常用：
        $0			获取文件名
        $num		获取第n个位置的参数内容
        $#			获取当前脚本的参数总数量
        $?			获取前一条指令的执行状态，成功返回0，否则返回非0
    很少用：
        $*			获取所有的参数内容，以字符串形式展示
        $@			获取所有的参数内容，以列表形式展示
        $$			获取当前进程号
        $?			获取上一个命令进程号
        
查看变量
	$变量名 ${变量名} "$变量名" "${变量名}"

取消变量
	unset 变量名
```

### 条件表达式

小结

```
判断表达式
	test xxx
	[ xxx ]
	条件成立返回0，否则返回1
	
分类
	逻辑 - 多个条件的执行逻辑
		&&、||
	文件 - 判断文件的类型
		-f|d
		-x
	数字 - 大小比较
		-eq|ne|gt|lt
	字符 - 内容匹配
		== | != 
		-z|n
```

### 逻辑组合

小结

```
条件组合
	!		反
	-a		与
	-o		或
	
逻辑组合 -- 条件组合的另外一种表现形式
	[[ 条件 || 条件 ]]  == [ 条件 -o 条件 ]
	[[ 条件 && 条件 ]]  == [ 条件 -a 条件 ]

```

### 计算表达式

小结

```
$((表达式))
let 变量名=表达式
expr 表达式
```

### 字符串基础

小结

```
长度计算
	${#变量名}
	expr length 变量名
	变量值 | awk '{print length}'
	
字符截取
	${string:偏移量:截取长度}
		偏移量是从 0开始计数
		偏移量不写代表第一个字符位置
		第二个冒号不写代表长度到最后一个字符
		-1是不包括最后一个字符的
		
转换
	${变量名^^}
	${变量名..}
```

### 字符串进阶

小结

```
字符串删除
	从右边开始删除
        ${变量名#删除的字符} 
        ${变量名##删除的字符正则}
    从左边开始删除
    	${变量名%删除的字符} 
		${变量名%%删除的字符正则}
	任意位置开始删除
		${变量名/删除的字符} 
		${变量名//删除的字符正则}
		
替换
	${string/正则表达式/替换内容} 将正则表达式 第一次 匹配到的信息替换成指定的信息 
	${string//正则表达式/替换内容} 将正则表达式 全部 匹配到的信息替换成指定的信息
	
赋值
	${string:-value}	如果string没有值，则返回value，但是string不变，否则返回string的值
	${string:=value}	如果string没有值，则返回value，同时string的值是value，否则返回string的值
	${string:+value}	如果string有值，value返回出去，如果string没有值，就算了
	${string:?value}	如果string没有值，则返回报错
	
	上面的四种情况，只要string有内容，则返回即可
```

### 数组实践

小结

```
创建数组
	定制空数组 declare -a array_name 
	定制数组 array_name=(value1 ... valuen) 
	定制数组(单值) array_name[0]=value0 
	定制稀疏数组 array_name=([index1]=v1 [index3]=v3 [index7]=v7) 
查看数组
	获取具体内容 ${array_name[index]} 
	获取长度 ${#array_name[index]} 
	获取内容的部分信息 ${array_name[index]:pos:length} 
	获取所有索引 ${!array_name[@]} 
	
更改数组
	更改具体值 array_name[index]=值
```

### 配置文件

小结

```
问题：
	为什么我在A终端定制的全局环境变量在B终端不生效？
	答案：全局环境变量的定制除了 export功能之外，还涉及到 环境配置文件的定制
	
配置文件
	系统级别
		/etc/profile 			系统默认的不要乱动
		/etc/profile.d/*		安装系统软件的时候，一些环境变量的定制都在这里
	用户级别
		~/.profile				自定义的一些用户习惯变量，比如别名等
	bash级别
		~/.bashrc				专属的shell环境下的配置，比如python虚拟环境等
```

## 流程控制

### if语句

小结

```
分类
	单分支 - 很少使用
	if
	then
	fi
	
	双分支 - 使用最多
	if
	then
	else
	fi
	
	多分支 - 有另外一个更好的
	if 
	then
	elif
	then
	else
	fi	
```

### case语句

小结

```
case 变量名 in 
值1)
	执行语句;;
。。。
*)
	执行语句;;
esac
```

### 循环控制

小结

```
for
	循环遍历，受范围数量限制
while
	只要条件满足，就一直循环下去
until
	只要条件不满足，就一直循环下去
	
格式
	关键字
	do
	done
```

### 循环终止

小结

```
break
	条件满足后，直接退出所有循环
continue
	条件满足后，退出当前循环，进入到下一个循环
```

### 函数

小结

```
简单函数定义和调用
	函数名(){
		函数体
	}
	函数名
	注意：
		先定义函数，然后再调用，避免报错
		
	解析
		问题在于，函数功能太单一，没有实现通用性
	
传参函数定义和调用
	函数名(){
		函数体 $n
	}
	函数名 参数
	
	解析
		函数本身的通用性实现了，但是对于当前脚本文件来说，通用性的功能太单一
		
	
脚本传参函数调用

	执行脚本：
		/bin/bash file.sh arg
	
	脚本内容：
        函数名(){
            函数体 $n
        }
        函数名 $n
	解析
		函数的通用性结合脚本的参数，实现了文件的功能通用性
		劣势：当我们的函数过多的时候，大量的位置参数，导致无法看得懂
		
脚本传参函数调用（生产用）

	执行脚本：
		/bin/bash file.sh arg
	
	脚本内容：
		# 定制本地变量
		script_arg=$n
		
        函数名(){
        	func_arg=$n
            函数体 $func_arg
        }
        函数名 $script_arg
    解析
    	借助于本地变量的方式，将大量的位置参数命名，应用到逻辑命令中，这样可以一目了然看到脚本的业务逻辑主线
```

小组作业

```
1 梳理 /etc/init.d/ssh 脚本
	主要是我们今天的知识点使用
2 改造脚本
	通过 echo语句，将逻辑替换，最终基于 脚本框架将我们的业务逻辑实现
```





