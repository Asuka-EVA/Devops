> 系统基础信息采集模块作为监控模块的重要组成部分，能够帮助运维人员了解当前系统的健康程度，同时也是衡量业务的服务质量的依据，比如系统资源吃紧，会直接影响业务的服务质量及用户体验，另外获取设备的流量信息，也可以让运维人员更好地评估带宽、设备资源是否应该扩容。本章通过运用Python第三方系统基础模块，可以轻松获取服务关键运营指标数据，包括Linux基本性能、块设备、网卡接口、系统信息、网络地址库等信息。在采集到这些数据后，我们就可以全方位了解系统服务的状态，再结合告警机制，可以在第一时间响应，将异常出现在苗头时就得以处理。

> 本章通过具体的示例来帮助读者学习、理解并掌握。在本章接下来的内容当中，我们的示例将在一个连续的 Python 交互环境中进行。

### 1.1 系统性能信息模块 psutil

> psutil是一个跨平台库(http://code.google.com/p/psutil/)，能够轻松实现获取系统运行的进程和系统利用率(包括CPU、内存、磁盘、网络等)信息。它主要应用于系统监控，分析和限制系统资源及进程的管理。它实现了同等命令行工具提供的功能，如ps、top、Isof、netstat、ifconfig、who、df、kill、free、nice、ionice、iostat、iotop、uptime、 pidof、tty.taskset、pmap等。目前支持32位和64位的Linux、Windows、OS X、FreeBSD和SunSolaris 等操作系统，支持从 2.4到3.4的Python版本，目前最新版本为 2.0.0。通常我们获取操作系统信息往往采用编写shell来实现，如获取当前物理内存总大小及已使用大小，shell命令如下:

```bash
#物理内存total值
[root@localhost ~]# free -m | grep Mem | awk '{print $2}'
#$2：第二列

#物理内存used值
[root@localhost ~]# free -m | grep Mem | awk '{print $3}'
```

> 相比较而言，使用 psutil库实现则更加简单明了。psutil大小单位一般都采用字节，如下:

```python
>>> import psutil
>>> mem = psutil.virtual_memory()
>>> mem.total,mem.used
(1911857152L, 999804928L)

#import psutil：导入了psutil模块。psutil（process and system utilities）是一个跨平台库，用于检索有关运行中进程和系统利用（如内存、CPU、磁盘、网络等）的信息。
#mem = psutil.virtual_memory()：调用psutil.virtual_memory()函数，该函数返回一个namedtuple，包含了不同内存使用情况的统计数据。这个namedtuple包含多个属性，如总内存（total）、已用内存（used）、空闲内存（free）等。
#mem.total,mem.used：获取namedtuple中的两个属性：total和used。mem.total：返回系统的总内存量，单位是字节。mem.used：返回系统已使用的内存量，也是字节。
```

> psutil的源码安装步骤如下:

```bash
#1.Centos7系统初始化
yum install vim lrzsz tree telnet wget lsof net-tools dos2unix sysstat traceroute unzip zip rsync gcc -y
#2.下载psutil-2.0.0.tar.gz
tar -xvzf psutil-2.0.0.tar.gz
[root@localhost ~]# cd psutil-2.0.0
#3.安装Python开发包
yum install python-devel  # 对于Python 2.x
#4.安装
[root@localhost psutil-2.0.0]# python setup.py  install
```

#### 1.1.1 获取系统性能信息

> 采集系统的基本性能信息包括 CPU、内存、磁盘、网络等，可以完整描述当前系统的运行状态及质量。psutil模块已经封装了这些方法，用户可以根据自身的应用场景，调用相应的方法来满足需求，非常简单实用。

> (1)CPU信息
>
> Linux操作系统的CPU 利用率有以下几个部分
>
> User Time，执行用户进程的时间百分比;
> System Time，执行内核进程和中断的时间百分比:;
>
> Wait 10，由于10 等待而使 CPU处于idle(空闲)状态的时间百分比;
>
> ldle，CPU 处于 idle 状态的时间百分比。

> 我们使用 Python的 psutil.cpu_times()方法可以非常简单地得到这些信息，同时也可以获取CPU的硬件相关信息，比如CPU的物理个数与逻辑个数，具体见下面的操作例子:

```python
>>> import psutil
>>> psutil.cpu_times()
scputimes(user=46.9, nice=2.55, system=43.76, idle=2437.96, iowait=2.65, irq=0.0, softirq=3.76, steal=0.0, guest=0.0, guest_nice=0.0)

#调用 cpu_times() 函数时，它返回一个名为 scputimes 的 namedtuple，包含了各种与CPU时间相关的统计数据
#user：用户模式下的CPU时间，表示CPU执行用户进程的时间（单位为秒）
#nice：低优先级（或“nice”）用户模式下的CPU时间。在UNIX-like系统中，"nice"值决定了进程的优先级，数值较高表示优先级较低。这一项表示系统分配给低优先级任务的CPU时间。
#system：内核模式下的CPU时间，表示CPU执行内核和驱动程序代码的时间。
#idle：空闲时间，表示CPU没有被任何程序使用的时间
#iowait： IO等待时间，表示CPU等待磁盘读写操作完成的时间。如果这个数值很高，通常意味着磁盘是系统的瓶颈
#irq：硬件中断请求时间，表示CPU响应硬件中断请求的时间
#softirq：软件中断请求时间，表示CPU响应软件中断请求的时间
#steal：虚拟化环境中，其他操作系统虚拟机占用的CPU时间。在没有虚拟化或者是物理机上，这个值通常是0。
#guest：表示运行虚拟CPU的客户操作系统所占用的CPU时间。
#guest_nice： 表示运行带有'nice'值的虚拟CPU的客户操作系统所占用的CPU时间。
```

```python
>>> import psutil
>>> psutil.cpu_times(percpu=True)
[scputimes(user=17.09, nice=1.31, system=20.28, idle=1934.99, iowait=0.87, irq=0.0, softirq=2.64, steal=0.0, guest=0.0, guest_nice=0.0), scputimes(user=30.34, nice=1.24, system=24.15, idle=1923.74, iowait=1.8, irq=0.0, softirq=1.15, steal=0.0, guest=0.0, guest_nice=0.0)]
#设置 percpu=True 参数意味着你想为每个CPU单独获取这些信息，而不是所有CPU的汇总数据。
#返回的结果是 scputimes 对象的列表，列表中的每个元素对应一个CPU核心的统计数据。这些数据与之前解释的 psutil.cpu_times() 返回的数据类似，但这次是为每个核心分别报告
```

```python
>>> import psutil
>>> psutil.cpu_times().user
47.53
#获取单项数据信息，如用户user的CPU时间比
```

```python
>>> import psutil
>>> psutil.cpu_count()
2
#获取CPU的逻辑个数，默认1ogical=True4
```

```python
>>> psutil.cpu_count(logical=False)
1
#获取CPU的物理颗数
```

(2)内存信息

> Linux系统的内存利用率信息涉及total(内存总数)、used(已使用的内存数)、free(空闲内存数)、buffers(缓冲使用数)、cache(缓存使用数)、swap(交换分区使用数)等，分别使用 psutil.virtual_memory()与psutil.swap_memory()方法获取这些信息，具体见下面的操作例子:

```python
>>> import psutil
>>> mem = psutil.virtual_memory()
>>> mem
svmem(total=1911857152L, available=1645944832L, percent=13.9, used=1013637120L, free=898220032L, active=466243584, inactive=367497216, buffers=2158592L, cached=745566208)
>>> 
#使用psutil.virtual_memory方法获取内存完整信息
>>> mem.total  #获取内存总数
1911857152L
>>> mem.free   #获取内存空闲数
898220032L
```

```python
>>> psutil.swap_memory()
sswap(total=2147479552L, used=0L, free=2147479552L, percent=0.0, sin=0, sout=0)
#获取swap交换分区的信息
```

> (3)磁盘信息
>
> 在系统的所有磁盘信息中，我们更加关注磁盘的利用率及IO信息，其中磁盘利用率使用psutil.disk_usage方法获取。磁盘IO信息包括read_count(读IO数)、write_count(写IO数)、read_bytes(IO读字节数)、write_bytes:(IO写字节数)、read_time(磁盘读时间)write_time(磁盘写时间)等。这些IO信息可以使用psutil.disk_io_counters()获取，具体见下面的操作例子:

```python
>>> import psutil
>>> psutil.disk_partitions()
[sdiskpart(device='/dev/mapper/centos-root', mountpoint='/', fstype='xfs', opts='rw,seclabel,relatime,attr2,inode64,noquota'), sdiskpart(device='/dev/sda1', mountpoint='/boot', fstype='xfs', opts='rw,seclabel,relatime,attr2,inode64,noquota')]
#使用psutil.disk_partitions方法获取磁盘完整信息
```

```python
>>> psutil.disk_usage('/')
sdiskusage(total=18238930944, used=1469235200, free=16769695744, percent=8.1)
#使用psutil.disk_usage方法获取分区(参数)的使用情况
```

```python
>>> psutil.disk_io_counters()
sdiskio(read_count=18691, write_count=29444, read_bytes=407959552, write_bytes=1669417472, read_time=22222, write_time=363652)
#使用psutil.disk_io_counters获取硬盘总的IO个数
```

```python
>>> psutil.disk_io_counters(perdisk=True)
{'sr0': sdiskio(read_count=18, write_count=0, read_bytes=1052672, write_bytes=0, read_time=218, write_time=0), 'dm-1': sdiskio(read_count=94, write_count=0, read_bytes=2281472, write_bytes=0, read_time=287, write_time=0), 'sda2': sdiskio(read_count=8454, write_count=12065, read_bytes=188959744, write_bytes=833671680, read_time=10761, write_time=48179), 'dm-0': sdiskio(read_count=8221, write_count=17379, read_bytes=185228288, write_bytes=833671680, read_time=9935, write_time=315467), 'sda1': sdiskio(read_count=1904, write_count=16, read_bytes=30437376, write_bytes=2138624, read_time=1021, write_time=22)}
#“perdisk=True”参数获取单个分区IO个数
```

> (4)网络信息
>
> 系统的网络信息与磁盘I0类似，涉及几个关键点，包括bytes_sent(发送字节数)bytes_recv=28220119(接收字节数)、packets_sent=200978(发送数据包数)、packets_recv=212672(接收数据包数)等。这些网络信息使用psutil.net_io_counters()方法获取，具体见下面的操作例子:

```python
>>> psutil.net_io_counters()
snetio(bytes_sent=1271117, bytes_recv=117538324, packets_sent=16472, packets_recv=82992, errin=0, errout=0, dropin=0, dropout=0)
>>> 
#使用psutil.net_io_counters获取网络总的IO信息，默认pernic=False
```

```python
>>> import psutil
>>> psutil.net_io_counters(pernic=True)
{'lo': snetio(bytes_sent=0, bytes_recv=0, packets_sent=0, packets_recv=0, errin=0, errout=0, dropin=0, dropout=0), 'ens33': snetio(bytes_sent=1281459, bytes_recv=117554194, packets_sent=16584, packets_recv=83202, errin=0, errout=0, dropin=0, dropout=0)}
#pernic=True输出每个网络接口的IO信息
```

> (5)其他系统信息
>
> 除了前面介绍的几个获取系统基本信息的方法，psutil模块还支持获取用户登录、开机时间等信息，具体见下面的操作例子:

```python
>>> psutil.users()
[suser(name='root', terminal='pts/0', host='192.168.112.1', started=1709463552.0)]
#使用psutil.users方法返回当前登录系统的用户信息
```

```python
>>> import psutil,datetime
>>> psutil.boot_time()
1709463485.0
#使用psutil.boot_time方法获取开始时间，以Linux时间戳格式返回
>>> 
>>> datetime.datetime.fromtimestamp(psutil.boot_time()).strftime("%Y-%m-%d %H:%M:%s")
'2024-03-03 18:58:1709463485'
#转换成自然语言的格式
```

#### 1.1.2 系统进程管理方法

> 获得当前系统的进程信息，可以让运维人员得知应用程序的运行状态，包括进程的启动时间、查看或设置 CPU亲和度、内存使用率、IO信息、socket连接、线程数等，这些信息可以呈现出指定进程是否存活、资源利用情况，为开发人员的代码优化、问题定位提供很好的数据参考。

> (1)进程信息
>
> psutil模块在获取进程信息方面也提供了很好的支持，包括使用psutil.pids()方法获取所有进程PID，使用psutil.Process()方法获取单个进程的名称、路径、状态、系统资源利用率等信息，具体见下面的操作例子:

```python
>>> import psutil
>>> psutil.pids()
[1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 36, 37, 38, 39, 47, 48, 49, 50, 51, 52, 53, 66, 102, 219, 274, 282, 283, 285, 287, 288, 290, 295, 296, 299, 300, 301, 303, 306, 307, 308, 379, 380, 391, 392, 405, 406, 407, 408, 409, 410, 411, 412, 413, 414, 415, 416, 496, 521, 530, 670, 671, 672, 673, 674, 677, 678, 686, 693, 695, 700, 704, 853, 940, 941, 943, 944, 945, 947, 948, 961, 1000, 1006, 1015, 1137, 1150, 1337, 1516, 1518, 1519, 1606, 1607, 1608, 1619, 1623, 1705]
#列出所有的PID
```

```python
>>> p = psutil.Process(1)#实例化一个Process对象，参数为一进程PID
>>> p.name() #进程名
'systemd'
>>> p.exe() #进程的bin路径
'/usr/lib/systemd/systemd'
>>> p.cwd() #进程工作目录绝对路径
'/'
>>> p.status() #进程状态
'sleeping'
>>> p.create_time() #进程创建时间，时间戳格式
1709530399.08
>>> p.uids() #进程uid信息
puids(real=0, effective=0, saved=0)
>>> p.gids() #进程gid信息
pgids(real=0, effective=0, saved=0)
>>> p.cpu_times() #进程cpu时间信息，包括user、system两个cpu时间
pcputimes(user=0.55, system=1.81)
>>> p.cpu_affinity() #get进程cpu亲和度，如果设置进程cpu亲和度，将cpu号作为参数即可
[0, 1]
>>> p.memory_percent() #进程内存利用率
0.3523238380809595
>>> p.memory_info() #进程内存rss、vms信息
pmem(rss=7315456, vms=198623232)
>>> p.io_counters() #进程IO信息，包括读写IO数及字节数
pio(read_count=36630, write_count=13513, read_bytes=65932288, write_bytes=9097216)
>>> p.connections() #返回打开进程socket的namedutples列表，包括fs、family、laddr等信息
[]
>>> p.num_threads() #进程开启的线程数
1
```

> (2)popen类的使用
>
> psutil 提供的 popen类的作用是获取用户启动的应用程序进程信息，以便跟踪程序进程的运行状态。具体实现方法如下:

```python
>>> import psutil
#导入psutil库，以便使用它提供的功能
>>> from subprocess import PIPE
#从subprocess模块导入PIPE。PIPE是一个特殊的常量，用于在创建子进程时指定某些流（如标准输出和标准错误输出）应该被管道到父进程
#通过psutil的Popen方法启动的应用程序，可以跟踪该程序运行的所有的信息
>>> p = psutil.Popen(["/usr/bin/python", "-c", "print('hello')"], stdout=PIPE)
#这行代码启动了一个新的Python进程，运行一个简单的命令print('hello')。这里的"/usr/bin/python"是Python解释器的路径，"-c"标志意味着后面的字符串是要执行的Python代码。stdout=PIPE意味着子进程的标准输出将被管道回父进程，允许父进程读取这些输出
>>> p.name()
'python'
#返回进程名称，这里是'python'，因为启动的是一个Python解释器进程
>>> p.username()
'root'
#返回启动该进程的用户名称，这里是'root'，意味着该进程是由root用户启动的
>>> p.communicate()
('hello\n', None)
#这个方法读取子进程的输出（如果有的话），并等待进程结束。它返回一个元组，其中包含子进程的标准输出和标准错误输出。在这个例子中，由于我们只关心标准输出，并且子进程没有错误，输出是('hello\n', None)。这表明子进程成功打印了'hello'，后面跟着一个换行符
>>> p.cpu_times()
pcputimes(user=0.01, system=0.040000000000000001)
#p.cpu_times()：返回一个pcputimes对象，包含子进程消耗的用户CPU时间和系统CPU时间。在这个例子中，用户时间是0.01秒，系统时间是0.04秒。这意味着子进程在用户模式下运行了0.01秒，在内核模式下运行了0.04秒
```

> 通过这段代码，可以看出`psutil`提供了一种方便的方式来启动子进程，并监控和交互这些进程的执行，包括获取进程的输出、名称、用户以及CPU使用情况等信息。

### 1.2 实用的IP地址处理模块IPy

> IP地址规划是网络设计中非常重要的一个环节，规划的好坏会直接影响路由协议算法的效率，包括网络性能、可扩展性等方面，在这个过程当中，免不了要计算大量的IP地址，包括网段、网络掩码、广播地址、子网数、IP 类型等。Python 提供了一个强大的第三方模块IPy(https:/github.com/haypo/python-ipy/)，最新版本为 V0.81。IPy模块可以很好地辅助我们高效完成IP的规划工作，下面进行详细介绍。

> 以下是 IPy模块的安装，这里采用源码的安装方式:

```bash
#下载安装包Ipy-0.81.tar.gz
tar -xvzf IPy-0.81.tar.gz 
cd IPy-0.81/
python setup.py install
```

#### 1.2.1 IP地址、网段的基础处理

> IPy模块包含类，使用它可以方便处理绝大部分格式为IPv6及IPv4的网络和地址。比如通过 version 方法就可以区分出IPv4与IPv6，如:

```python
>>> from IPy import IP
>>> IP('10.0.0.0/8').version()
4
>>> IP('::1').version()
6
>>> 
```

> 通过指定的网段输出该网段的IP个数及所有P地址清单，代码如下:

```python
>>> from IPy import IP
>>> ip = IP('192.168.0.0/16')
>>> print ip.len() #输出192.168.0.0/16网段的IP个数
65536
```

```python
>>> from IPy import IP
>>> ip = IP('192.168.0.0/16')
>>> for x in ip:
...     print(x)
... 
```

> 下面介绍 IP 类几个常见的方法，包括反向解析名称、IP类型、IP转换等。

```python
>>> from IPy import IP
>>> ip = IP('192.168.1.20')
>>> ip.reverseNames() #反向解析地址格式
['20.1.168.192.in-addr.arpa.']
>>> ip.iptype() #为私网类型PRIVATE
'PRIVATE'
>>> IP('8.8.8.8').iptype() #8.8.8.8为公网类型
'PUBLIC'
>>> IP("8.8.8.8").int() #转换为整型格式
134744072
>>> IP('8.8.8.8').strHex() #转换成十六进制格式
'0x8080808'
>>> IP('8.8.8.8').strBin() #转换成二进制格式
'00001000000010000000100000001000'
>>> print(IP(0x8080808)) #十六进制转成IP格式
8.8.8.8
```

> IP方法也支持网络地址的转换，例如根据IP与掩码生产网段格式，如下:

```python
>>> from IPy import IP
>>> print(IP('192.168.1.0').make_net('255.255.255.0'))
192.168.1.0/24
>>> print(IP('192.168.1.1/255.255.255.0', make_net=True))
192.168.1.0/24
>>> print(IP('192.168.1.0-192.168.1.255', make_net=True))
192.168.1.0/24
```

> 也可以通过 strNormal方法指定不同 wantprefxlen参数值以定制不同输出类型的网段输出类型为字符串，如下:

```python
>>> IP('192.168.1.0/24').strNormal(0)
'192.168.1.0'
>>> IP('192.168.1.0/24').strNormal(1)
'192.168.1.0/24'
>>> IP('192.168.1.0/24').strNormal(2)
'192.168.1.0/255.255.255.0'
>>> IP('192.168.1.0/24').strNormal(3)
'192.168.1.0-192.168.1.255'
```

> wantprefxlen的取值及含义:

```bash
wantprefxlen=0，无返回，如192.168.1.0;
wantprefxlen=1，prefix格式，如192.168.1.0/24;
wantprefxlen=2,decimalnetmask格式，如192.168.1.0/255.255.255.0;
wantprefxlen=3,lastIP格式，如192.168.1.0-192.168.1.255。
```

#### 1.2.2 多网络计算方法详解

> 有时候我们想比较两个网段是否存在包含、重叠等关系，比如同网络但不同prefxlen 会认为是不相等的网段，如10.0.0.0/16不等于10.0.0.0/24，另外即使具有相同的 prefxlen但处于不同的网络地址，同样也视为不相等，如10.0.0.0/16不等于192.0.0.0/16。IPy支持类似于数值型数据的比较，以帮助IP对象进行比较，如:
>

```python
>>> from IPy import IP
>>> IP('10.0.0.0/24') < IP('12.0.0.0/24')
True
```

> 判断IP地址和网段是否包含于另一个网段中，如下:
>

```python
>>> '192.168.1.100' in IP('192.168.1.0/24')
True
>>> IP('192.168.1.0/24') in IP('192.168.0.0/16')
True
>>> 
```

> 判断两个网段是否存在重叠，采用IPy提供的overlaps方法，如:
>

```python
>>> IP('192.168.0.0/23').overlaps('192.168.1.0/24')
1#返回1代表存在重叠
>>> IP('192.168.0.0/24').overlaps('192.168.2.0')
0#返回0代表不存在重叠
```

> 根据输入的 IP 或子网返回网络、掩码、广播、反向解析、子网数、IP 类型等信息。
>

```python
#!/usr/bin/env python

from IPy import IP

ip_s = raw_input('Please input an IP or net-range: ') #接受用户输入，参数为IP地址或网段地址
ips = IP(ip_s)


if len(ips) > 1:#为一个网络地址
    print('net: %s' % ips.net()) #输出网络地址
    print('netmask: %s' % ips.netmask()) #输出网络掩码地址
    print('broadcast: %s' % ips.broadcast()) #输出网络广播地址
    print('reverse address: %s' % ips.reverseNames()[0]) #输出地区反向解析
    print('subnet: %s' % len(ips)) #输出网络子网数
else: #为单个IP地址
    print('reverse address: %s' % ips.reverseNames()[0]) #输出IP反向解析

print('hexadecimal: %s' % ips.strHex()) #输出十六进制地址
print('binary ip: %s' % ips.strBin()) #输出二进制地址
print('iptype: %s' % ips.iptype()) #输出地址类型，如PRIVATE、PUBLIC、LOOPBACK等
```

> 分别输入网段、IP地址的运行返回结果如下：
>

```bash
[root@JackBao ~]# python simplel.py 
Please input an IP or net-range: 192.168.1.0/24
net: 192.168.1.0
netmask: 255.255.255.0
broadcast: 192.168.1.255
reverse address: 1.168.192.in-addr.arpa.
subnet: 256
hexadecimal: 0xc0a80100
binary ip: 11000000101010000000000100000000
iptype: PRIVATE

[root@JackBao ~]# python simplel.py 
Please input an IP or net-range: 192.168.1.20
reverse address: 20.1.168.192.in-addr.arpa.
hexadecimal: 0xc0a80114
binary ip: 11000000101010000000000100010100
iptype: PRIVATE
```

### 1.3 DNS处理模块

